<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Algoritms</title>
    <link rel="stylesheet" href="css/design.css">
  </head>
  <body>
    <div class="intro">
      <h1>Algoritms</h1>
    </div>
    <br><br>
    <div style="width: 100%" >
        <div style="display: inline-block; width: 33.33%">
            <div class="algorithm-header">
                <h2>Алгоритм кластеризации</h2>
            </div>
            <div class="algorithm-description">
                <p>Данный алгоритм относится к методам кластеризации, а именно - к методу k-средних. Он используется для группировки точек в n кластеров на основе их координат. <br></p>
                <p></p>Алгоритм начинает с генерации случайных центров кластеров. Количество кластеров определяется параметром clusterCount. Затем каждая точка из массива pointsC, представляющего собой координаты всех точек на холсте, прикрепляется к ближайшему кластеру на основе расстояния между точками и центрами кластеров. Это делается с помощью поиска ближайшего центра и добавления точки к кластеру, который соответствует этому центру.<br>
                <p></p>Затем алгоритм пересчитывает координаты центров кластеров, определяя новые центры кластеров на основе средних координат всех точек, которые относятся к этому кластеру. Это делается в несколько итераций, которое определяется переменной iterations.<br>
                <p></p>После того, как центры кластеров были пересчитаны, точки закрашиваются цветами кластеров, к которым они были прикреплены на предыдущих итерациях. Закрашивание происходит путем присвоения каждой точке цвета ближайшего центра кластера.<br>
                <p></p>Наконец, функция drawPointsC() используется для отображения точек на холсте в соответствии с цветами кластеров. Результат работы этого алгоритма - группировка точек на холсте в n кластеров на основе их координат.<br>
            </div>
        </div>
        <div style="display: inline-block; width: 33.33%">
            <canvas id="firstCanvas" width="600" height="600"></canvas>
        </div>
        <div style="display: inline-block; width: 33.33%">
            <div class="button-container" style="position: absolute; right: 3vw; top: 120vh;">
                <label for="cluster-count">Количество кластеров</label>
                <input type="number" id="cluster-count" value="3" min="1" max="10" placeholder="1-10">
                <p><button class="my-button" id="clear-buttonC">Очистить</button></p>
                <p><button class="my-button" id="cluster-button">Начать</button></p>
            </div>
        </div>
        <script src="js/clasterButton.js"></script>
        <script src="js/clastering.js"></script>
    </div>
    <br><br><br><br>
    <div style="width: 100%" >
        <div style="display: inline-block; width: 33.33%">
            <div class="algorithm-header">
                <h2>Генетический алгоритм</h2>
            </div>
            <div class="algorithm-description">
                <p></p>Данный алгоритм предназначен для решения задачи коммивояжера. Задача коммивояжера заключается в том, чтобы найти кратчайший маршрут, который проходит через каждый город только один раз и возвращается в начальный город.<br>
                <p></p>Алгоритм начинается с создания начальной популяции хромосом (маршрутов), где каждая хромосома представляет собой случайную последовательность городов, через которые должен проходить маршрут. Затем для каждой хромосомы вычисляется длина маршрута с помощью функции calculateRouteLength, которая суммирует расстояние между каждой парой городов в порядке, заданном в хромосоме.<br>
                <p></p>Далее алгоритм запускает цикл, в котором происходит эволюция популяции. На каждой итерации цикла происходит выбор лучших родителей с помощью функции selectParent, которая использует турнирный отбор, и создание потомства (новой хромосомы) с помощью оператора кроссинговера crossover и оператора мутации mutate. Оператор кроссинговера выбирает случайную точку в хромосоме и создает новую хромосому, которая наследует первую часть одного родителя и вторую часть другого. Оператор мутации случайным образом выбирает два гена (города) в хромосоме и меняет их местами.<br>
                <p></p>Затем для каждой новой хромосомы вычисляется длина маршрута с помощью функции calculateRouteLength, и лучшая хромосома сохраняется как решение задачи коммивояжера. На каждой итерации цикла отображается текущее состояние популяции и лучший найденный маршрут.<br>
                <p></p>Цикл продолжается до тех пор, пока не будет достигнуто максимальное число итераций maxGenerations. После завершения цикла алгоритм возвращает лучшую найденную хромосому, которая представляет собой кратчайший маршрут для задачи коммивояжера.<br>
            </div>
        </div>
        <div style="display: inline-block; width: 33.33%">
            <canvas id="secondCanvas" width="600" height="750"></canvas>
        </div>
        <div style="display: inline-block; width: 33.33%">
            <div class="button-container" style="position: absolute; right: 3vw; top: 210vh;">
                <label for="population-size">Размер популяции</label>
                <input type="number" id="population-size" value="7" min="2" max="15" placeholder="2-20">
                <p><label for="genetic-count">Количество поколений</label></p>
                <input type="number" id="genetic-count" value="300" min="300" max="10000" placeholder="300-10000">
                <p><button class="my-button" id="clear-buttonG">Очистить</button></p>
                <p><button class="my-button" id="genetic-button">Начать</button></p>
            </div>
        </div>
        <script src="js/geneticButton.js"></script>
        <script src="js/geneticDrawing.js"></script>
        <script src="js/geneticAlgoritm.js"></script>
    </div>
    <br><br><br><br>
    <div style="width: 100%" >
        <div style="display: inline-block; width: 33.33%">
            <div class="algorithm-header">
                <h2>Муравьиный алгоритм</h2>
            </div>
            <div class="algorithm-description">
                <p></p>Алгоритм использует муравьев, которые перемещаются по графу городов, и оставляют феромоны на своем пути. Феромоны привлекают других муравьев, увеличивая вероятность выбора определенного пути. <br>
                <p></p>В начале кода определены параметры генетического алгоритма, такие как количество муравьев в популяции и количество итераций. Затем определены коэффициенты для расчета вероятностей выбора следующего города и коэффициенты для расчета количества феромонов, которые будут оставлены на пути муравьев.<br>
                <p></p>Далее происходит инициализация феромонов, которые устанавливаются на всех возможных путях между городами с начальным значением, указанным в переменной initialPheromoneLevel.<br>
                <p></p>Затем происходит основной цикл алгоритма, в котором генерируются пути муравьев, расчитываются их длины, обновляются феромоны и ищется лучший путь.<br>
                <p></p>В каждой итерации цикла происходит генерация путей муравьев. Каждый муравей начинает свой путь в случайном городе. Затем муравей перемещается на следующий город, выбирая его на основе вероятности, которая зависит от количества феромонов на пути и расстояния между городами. Вероятность выбора определенного города определяется с помощью формулы, в которой используются коэффициенты alpha и beta:<br>
                <p></p>probability = (pheromoneLevel ^ alpha) * ((1 / distance) ^ beta)<br>
                <p></p>Затем феромоны обновляются на основе лучшего найденного пути. Для каждого города в пути увеличивается количество феромонов, оставленных на пути муравьем. Количество феромонов, которые будут добавлены, зависит от длины пути.<br>
                <p></p>В конце каждой итерации происходит поиск лучшего пути, который имеет наименьшую длину, и обновляется переменная bestPath.<br>
                <p></p>После завершения всех итераций алгоритма, лучший найденный путь выводится на экран.<br>
            </div>
        </div>
        <div style="display: inline-block; width: 33.33%">
            <canvas id="thirdCanvas" width="600" height="850"></canvas>
        </div>
        <div style="display: inline-block; width: 33.33%">
            <div class="button-container" style="position: absolute; right: 3vw; top: 330vh;">
                <label for="ant-population">Количество колоний</label>
                <input type="number" id="ant-population" value="7" min="2" max="15" placeholder="2-20">
                <p><label for="iterate-count">Количество итераций</label></p>
                <input type="number" id="iterate-count" value="300" min="300" max="10000" placeholder="1000-5000">
                <p><button class="my-button" id="clear-buttonA">Очистить</button></p>
                <p><button class="my-button" id="antAlgoritm-button">Начать</button></p>
            </div>
        </div>
        <script src="js/antButton.js"></script>
        <script src="js/antDrawing.js"></script>
    </div>
  </body>
</html>
